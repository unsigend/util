{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#overview","title":"Overview","text":"<p>Util is a modern, lightweight C utility library that extends the standard C library by providing additional essential modules. Designed with simplicity and modularity in mind, it offers a collection of reusable components that can be easily integrated into any C project.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Modular Design: Each module is independent and can be used separately</li> <li>Header-Only: Most modules are header-only, making integration simple</li> <li>Cross-Platform: Works on Linux, macOS, and Windows</li> <li>C++ Compatible: All modules are compatible with C++ code</li> <li>MIT Licensed: Free to use in both open-source and commercial projects</li> <li>Zero Dependencies: No external dependencies required</li> <li>Modern C: Written in modern C with clean, maintainable code</li> </ul>"},{"location":"#requirements","title":"Requirements","text":""},{"location":"#build-dependencies","title":"Build Dependencies","text":"<ul> <li>C Compiler: GCC or Clang with C11 support</li> <li>Make: GNU Make 3.81 or later</li> <li>Standard C Library: glibc or compatible</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#1-clone-the-repository","title":"1. Clone the Repository","text":"<pre><code>git clone https://github.com/unsigend/util.git\ncd util\n</code></pre>"},{"location":"#2-configure-modules","title":"2. Configure Modules","text":"<p>Configure modules in <code>config/config.mk</code> (all modules are included by default).</p>"},{"location":"#3-build-and-install","title":"3. Build and Install","text":"<p>Build all modules:</p> <pre><code>make all\n</code></pre> <p>Install headers to the install path:</p> <pre><code>make install\n</code></pre>"},{"location":"#4-use-the-library","title":"4. Use the Library","text":"<p>Include the library in your project:</p> <pre><code>#include &lt;utest.h&gt;\n#include &lt;argparse.h&gt;\n</code></pre> <p>Link against the library:</p> <pre><code>gcc -I./include your_program.c -L./lib -lutil -o your_program\n</code></pre>"},{"location":"#build-configuration","title":"Build Configuration","text":"<p>The build system is configured via <code>config/config.mk</code>:</p> <ul> <li>C Standard: c11</li> <li>Build Method: static or shared</li> <li>Library Name: util</li> <li>Modules: Select which modules to include</li> </ul> <p>To change the build method, edit <code>config/config.mk</code>:</p> <pre><code>LIB_METHOD := static  # or shared\n</code></pre> <p>Then rebuild:</p> <pre><code>make clean\nmake all\n</code></pre>"},{"location":"#available-make-targets","title":"Available Make Targets","text":"<p>Everything is managed through Makefile. Use <code>make help</code> to see detailed commands:</p> Target Description <code>make all</code> Build all modules <code>make clean</code> Clean builds <code>make list</code> List all modules <code>make help</code> Show this help message <code>make test-[module]</code> Build test for [module] <code>make clean-[module]</code> Clean test for [module] <code>make clean-all</code> Completely clean all builds <code>make install</code> Install all headers to install path <code>make docs</code> Build and serve documentation <p>You can change the configuration in <code>config/config.mk</code>.</p>"},{"location":"#why-util","title":"Why Util?","text":"<ul> <li>Simplicity: Each module is designed to be simple to use while providing powerful features</li> <li>Modularity: Use only what you need, reducing code bloat</li> <li>Maintainability: Clean, well-documented code that's easy to understand and modify</li> <li>Reliability: Thoroughly tested with comprehensive unit tests</li> <li>Community: Open to contributions and improvements</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Whether it's:</p> <ul> <li>Bug reports</li> <li>Feature requests</li> <li>Documentation improvements</li> <li>Code contributions</li> </ul> <p>Please feel free to:</p> <ol> <li>Open an issue to discuss proposed changes</li> <li>Fork the repository</li> <li>Submit a pull request</li> </ol>"},{"location":"#building-documentation","title":"Building Documentation","text":"<p>The documentation is built using MkDocs with Material theme.</p> <p>To build and serve the documentation locally:</p> <pre><code>make docs\n</code></pre> <p>This will:</p> <ul> <li>Create a Python virtual environment if needed</li> <li>Install dependencies automatically</li> <li>Build the documentation</li> <li>Start a local server at <code>http://127.0.0.1:8000</code></li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License. Copyright (C) 2025 - 2026 QIU YIXIANG</p>"},{"location":"argparse/","title":"Argparse","text":"<p>The <code>Argparse</code> module provides a lightweight, flexible command line argument parser for C, designed to make parsing command line arguments simple and expressive. It provides a rich set of options for handling different types of arguments and supports both short and long options.</p>"},{"location":"argparse/#header-files","title":"Header Files","text":"<p>To use the argparse module in your code, include the header file:</p> <pre><code>#include &lt;argparse.h&gt;\n</code></pre> <p>This provides access to all parsing functions and macros for defining command-line options.</p>"},{"location":"argparse/#getting-started","title":"Getting Started","text":"<p>To use argparse, you need to:</p> <ol> <li>Define your command-line options using the provided macros</li> <li>Create a description structure for your program</li> <li>Initialize and parse the arguments</li> </ol> <p>The library handles all internal structures automatically - you only need to work with the macros and functions described below.</p>"},{"location":"argparse/#macros","title":"Macros","text":""},{"location":"argparse/#option_end","title":"OPTION_END","text":"<pre><code>OPTION_END()\n</code></pre> <p>Marks the end of the option array. Must be the last element in an option array.</p> <p>Example:</p> <pre><code>struct argparse_option options[] = {\n    OPTION_STRING('f', \"file\", \"input file\", &amp;file_path, NULL, 0),\n    OPTION_END()\n};\n</code></pre>"},{"location":"argparse/#option_group","title":"OPTION_GROUP","text":"<pre><code>OPTION_GROUP(DESCRIPTION)\n</code></pre> <p>Defines a group of options for organization in help output.</p> <p>Parameters:</p> <ul> <li><code>DESCRIPTION</code> - The description/name of the group</li> </ul> <p>Example:</p> <pre><code>struct argparse_option options[] = {\n    OPTION_GROUP(\"Basic Options\"),\n    OPTION_STRING('f', \"file\", \"input file\", &amp;file_path, NULL, 0),\n    OPTION_GROUP_END(),\n    OPTION_END()\n};\n</code></pre>"},{"location":"argparse/#option_group_end","title":"OPTION_GROUP_END","text":"<pre><code>OPTION_GROUP_END()\n</code></pre> <p>Marks the end of an option group.</p> <p>Example:</p> <pre><code>struct argparse_option options[] = {\n    OPTION_GROUP(\"Basic Options\"),\n    OPTION_STRING('f', \"file\", \"input file\", &amp;file_path, NULL, 0),\n    OPTION_GROUP_END(),\n    OPTION_END()\n};\n</code></pre>"},{"location":"argparse/#option_boolean","title":"OPTION_BOOLEAN","text":"<pre><code>OPTION_BOOLEAN(SHORT_NAME, LONG_NAME, DESCRIPTION, VALUE, CALLBACK, CALLBACK_DATA)\n</code></pre> <p>Defines a boolean option (flag) that doesn't take a value.</p> <p>Parameters:</p> <ul> <li><code>SHORT_NAME</code> - Short option name (single character, use 0 for none)</li> <li><code>LONG_NAME</code> - Long option name (string, use NULL for none)</li> <li><code>DESCRIPTION</code> - Description shown in help message</li> <li><code>VALUE</code> - Pointer to integer variable to store the flag state</li> <li><code>CALLBACK</code> - Optional callback function (NULL if not needed)</li> <li><code>CALLBACK_DATA</code> - Optional data passed to callback</li> </ul> <p>Example:</p> <pre><code>int verbose = 0;\nstruct argparse_option options[] = {\n    OPTION_BOOLEAN('v', \"verbose\", \"enable verbose output\", &amp;verbose, NULL, 0),\n    OPTION_END()\n};\n</code></pre>"},{"location":"argparse/#option_string","title":"OPTION_STRING","text":"<pre><code>OPTION_STRING(SHORT_NAME, LONG_NAME, DESCRIPTION, VALUE, CALLBACK, CALLBACK_DATA)\n</code></pre> <p>Defines a string option that takes a string value.</p> <p>Parameters:</p> <ul> <li><code>SHORT_NAME</code> - Short option name (single character, use 0 for none)</li> <li><code>LONG_NAME</code> - Long option name (string, use NULL for none)</li> <li><code>DESCRIPTION</code> - Description shown in help message</li> <li><code>VALUE</code> - Pointer to <code>const char*</code> variable to store the string value</li> <li><code>CALLBACK</code> - Optional callback function (NULL if not needed)</li> <li><code>CALLBACK_DATA</code> - Optional data passed to callback</li> </ul> <p>Example:</p> <pre><code>const char *file_path = NULL;\nstruct argparse_option options[] = {\n    OPTION_STRING('f', \"file\", \"input file path\", &amp;file_path, NULL, 0),\n    OPTION_END()\n};\n</code></pre>"},{"location":"argparse/#option_int","title":"OPTION_INT","text":"<pre><code>OPTION_INT(SHORT_NAME, LONG_NAME, DESCRIPTION, VALUE, CALLBACK, CALLBACK_DATA)\n</code></pre> <p>Defines an integer option that takes an integer value.</p> <p>Parameters:</p> <ul> <li><code>SHORT_NAME</code> - Short option name (single character, use 0 for none)</li> <li><code>LONG_NAME</code> - Long option name (string, use NULL for none)</li> <li><code>DESCRIPTION</code> - Description shown in help message</li> <li><code>VALUE</code> - Pointer to integer variable to store the value</li> <li><code>CALLBACK</code> - Optional callback function (NULL if not needed)</li> <li><code>CALLBACK_DATA</code> - Optional data passed to callback</li> </ul> <p>Example:</p> <pre><code>int iterations = 1;\nstruct argparse_option options[] = {\n    OPTION_INT('n', \"number\", \"number of iterations\", &amp;iterations, NULL, 0),\n    OPTION_END()\n};\n</code></pre>"},{"location":"argparse/#option_double","title":"OPTION_DOUBLE","text":"<pre><code>OPTION_DOUBLE(SHORT_NAME, LONG_NAME, DESCRIPTION, VALUE, CALLBACK, CALLBACK_DATA)\n</code></pre> <p>Defines a double option that takes a floating-point value.</p> <p>Parameters:</p> <ul> <li><code>SHORT_NAME</code> - Short option name (single character, use 0 for none)</li> <li><code>LONG_NAME</code> - Long option name (string, use NULL for none)</li> <li><code>DESCRIPTION</code> - Description shown in help message</li> <li><code>VALUE</code> - Pointer to double variable to store the value</li> <li><code>CALLBACK</code> - Optional callback function (NULL if not needed)</li> <li><code>CALLBACK_DATA</code> - Optional data passed to callback</li> </ul> <p>Example:</p> <pre><code>double threshold = 0.5;\nstruct argparse_option options[] = {\n    OPTION_DOUBLE('t', \"threshold\", \"threshold value\", &amp;threshold, NULL, 0),\n    OPTION_END()\n};\n</code></pre>"},{"location":"argparse/#option_help","title":"OPTION_HELP","text":"<pre><code>OPTION_HELP()\n</code></pre> <p>Adds a built-in help option (<code>-h</code>, <code>--help</code>) that displays the help message and exits.</p> <p>Example:</p> <pre><code>struct argparse_option options[] = {\n    OPTION_HELP(),\n    OPTION_STRING('f', \"file\", \"input file\", &amp;file_path, NULL, 0),\n    OPTION_END()\n};\n</code></pre>"},{"location":"argparse/#functions","title":"Functions","text":"<p>Public interfaces for argument parsing operations:</p>"},{"location":"argparse/#argparse_init","title":"argparse_init","text":"<pre><code>void argparse_init(struct argparse *this, const struct argparse_option *option_list, \n    const struct argparse_description *description);\n</code></pre> <p>Initializes an argparse instance with options and description.</p> <p>Parameters:</p> <ul> <li><code>this</code> - Pointer to the argparse struct to initialize</li> <li><code>option_list</code> - Pointer to array of options (must end with <code>OPTION_END()</code>)</li> <li><code>description</code> - Pointer to description struct (can be NULL)</li> </ul> <p>Example:</p> <pre><code>struct argparse argparse;\nstruct argparse_description desc = {\n    \"My Program Description\",\n    \"Additional information at the end of help\",\n    \"Usage: program [options]\",\n    \"program\"\n};\n\nstruct argparse_option options[] = {\n    OPTION_HELP(),\n    OPTION_STRING('f', \"file\", \"input file\", &amp;file_path, NULL, 0),\n    OPTION_END()\n};\n\nargparse_init(&amp;argparse, options, &amp;desc);\n</code></pre>"},{"location":"argparse/#argparse_set_flags","title":"argparse_set_flags","text":"<pre><code>void argparse_set_flags(struct argparse *this, argparse_flag flags);\n</code></pre> <p>Sets the behavior flags for the argparse instance.</p> <p>Parameters:</p> <ul> <li><code>this</code> - Pointer to the argparse struct</li> <li><code>flags</code> - Flags to set (can be combined with bitwise OR)</li> </ul> <p>Example:</p> <pre><code>struct argparse argparse;\nargparse_init(&amp;argparse, options, &amp;desc);\nargparse_set_flags(&amp;argparse, ARGPARSE_FLAG_IGNORE_UNKNOWN_OPTION);\n</code></pre>"},{"location":"argparse/#argparse_parse","title":"argparse_parse","text":"<pre><code>void argparse_parse(struct argparse *this, int argc, char *argv[]);\n</code></pre> <p>Parses command line arguments according to the defined options.</p> <p>Parameters:</p> <ul> <li><code>this</code> - Pointer to the argparse struct</li> <li><code>argc</code> - Number of command line arguments</li> <li><code>argv</code> - Array of command line argument strings</li> </ul> <p>Note: The <code>argv[0]</code> from the main function is typically not accepted by argparse. Usually call <code>argparse_parse(this, argc - 1, argv + 1)</code> to skip the program name.</p> <p>Example:</p> <pre><code>int main(int argc, char *argv[]) {\n    struct argparse argparse;\n    argparse_init(&amp;argparse, options, &amp;desc);\n    // Skip the program name\n    argparse_parse(&amp;argparse, argc - 1, argv + 1);\n    return 0;\n}\n</code></pre>"},{"location":"argparse/#built-in-callback-functions","title":"Built-in Callback Functions","text":""},{"location":"argparse/#argparse_callback_help","title":"argparse_callback_help","text":"<pre><code>extern void argparse_callback_help(struct argparse* this, const struct argparse_option *option);\n</code></pre> <p>Built-in callback function for the help option. Automatically added when using <code>OPTION_HELP()</code> macro. Prints help message and exits the program.</p> <p>Note: No side effects, just prints the help message.</p>"},{"location":"argparse/#argparse_callback_multiple_arguments","title":"argparse_callback_multiple_arguments","text":"<pre><code>extern void argparse_callback_multiple_arguments(struct argparse* this, const struct argparse_option *option);\n</code></pre> <p>Built-in callback function for handling multiple arguments for an option. Used for collecting string type arguments.</p> <p>Usage:</p> <p>When defining an option that accepts multiple values, pass the callback function and the array size as the callback data.</p> <p>Example:</p> <pre><code>const char *files[10];\nstruct argparse_option options[] = {\n    OPTION_STRING('f', \"file\", \"input files\", files, argparse_callback_multiple_arguments, 10),\n    OPTION_END()\n};\n</code></pre>"},{"location":"argparse/#usage-examples","title":"Usage Examples","text":""},{"location":"argparse/#basic-usage","title":"Basic Usage","text":"<pre><code>#include &lt;argparse.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(int argc, char *argv[]) {\n    const char *input_file = NULL;\n    int iterations = 1;\n    int verbose = 0;\n\n    struct argparse_option options[] = {\n        OPTION_GROUP(\"Basic Options\"),\n        OPTION_HELP(),\n        OPTION_STRING('f', \"file\", \"input file path\", &amp;input_file, NULL, 0),\n        OPTION_INT('n', \"number\", \"number of iterations\", &amp;iterations, NULL, 0),\n        OPTION_BOOLEAN('v', \"verbose\", \"enable verbose output\", &amp;verbose, NULL, 0),\n        OPTION_GROUP_END(),\n        OPTION_END()\n    };\n\n    struct argparse_description desc = {\n        \"A sample program demonstrating argparse usage\",\n        \"For more information, see the documentation\",\n        \"Usage: sample [options]\",\n        \"sample\"\n    };\n\n    struct argparse argparse;\n    argparse_init(&amp;argparse, options, &amp;desc);\n    argparse_parse(&amp;argparse, argc - 1, argv + 1);\n\n    // Use the parsed values\n    if (input_file) {\n        printf(\"Processing file: %s\\n\", input_file);\n    }\n    printf(\"Iterations: %d\\n\", iterations);\n    if (verbose) {\n        printf(\"Verbose mode enabled\\n\");\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"argparse/#with-custom-callback","title":"With Custom Callback","text":"<pre><code>#include &lt;argparse.h&gt;\n#include &lt;stdio.h&gt;\n\nvoid my_callback(struct argparse* this, const struct argparse_option *option) {\n    printf(\"Option was parsed\\n\");\n    // Custom handling logic here\n}\n\nint main(int argc, char *argv[]) {\n    const char *file_path = NULL;\n\n    struct argparse_option options[] = {\n        OPTION_STRING('f', \"file\", \"input file\", &amp;file_path, my_callback, 0),\n        OPTION_END()\n    };\n\n    struct argparse_description desc = {\n        \"My Program\",\n        NULL,\n        \"Usage: program [options]\",\n        \"program\"\n    };\n\n    struct argparse argparse;\n    argparse_init(&amp;argparse, options, &amp;desc);\n    argparse_parse(&amp;argparse, argc - 1, argv + 1);\n\n    return 0;\n}\n</code></pre>"},{"location":"argparse/#important-notes","title":"Important Notes","text":""},{"location":"argparse/#memory-management","title":"Memory Management","text":"<ul> <li>The argparse library does not allocate memory for option values</li> <li>String values are stored as pointers to the original argument strings</li> <li>The user is responsible for managing the lifetime of string values</li> </ul>"},{"location":"argparse/#option-parsing","title":"Option Parsing","text":"<ul> <li>Options can have both short (<code>-f</code>) and long (<code>--file</code>) forms</li> <li>Boolean options don't require a value</li> <li>String, integer, and double options require a value</li> <li>Unknown options will stop parsing by default (can be changed with <code>argparse_set_flags()</code>)</li> </ul>"},{"location":"argparse/#thread-safety","title":"Thread Safety","text":"<p>Argparse operations are not thread-safe. External synchronization is required for concurrent access.</p>"},{"location":"argparse/#important-usage-notes","title":"Important Usage Notes","text":"<ul> <li>Always end your option array with <code>OPTION_END()</code></li> <li>Don't modify option arrays or description structures after initialization</li> <li>String values point to the original <code>argv</code> strings - ensure they remain valid during use</li> <li>Check return values and handle errors appropriately</li> </ul>"},{"location":"configparse/","title":"Configparse","text":"<p>The <code>Configparse</code> module provides a lightweight, modular INI configuration parser for C, designed to make parsing and managing INI-style configuration files simple and efficient. It provides a rich set of functions for reading, parsing, and accessing configuration data from INI files.</p>"},{"location":"configparse/#header-files","title":"Header Files","text":"<p>To use the configparse module in your code, include the header file:</p> <pre><code>#include &lt;configparse.h&gt;\n</code></pre> <p>This provides access to all parsing functions for reading INI configuration files.</p>"},{"location":"configparse/#getting-started","title":"Getting Started","text":"<p>To use configparse, you need to:</p> <ol> <li>Initialize a parser with a configuration file</li> <li>Parse the file using either a callback function or get specific values</li> <li>The library handles all internal file management automatically</li> </ol>"},{"location":"configparse/#callback-function-type","title":"Callback Function Type","text":""},{"location":"configparse/#configparse_callback_t","title":"configparse_callback_t","text":"<p>Callback function type for handling parsed key-value pairs:</p> <pre><code>typedef void (*configparse_callback_t)(void * data, const char * section, const char * key, const char * value);\n</code></pre> <p>This function is called for each key-value pair found during parsing.</p> <p>Parameters:</p> <ul> <li><code>data</code> - User-provided data pointer</li> <li><code>section</code> - Current section name (including subsections in quotes)</li> <li><code>key</code> - Configuration key</li> <li><code>value</code> - Configuration value</li> </ul>"},{"location":"configparse/#functions","title":"Functions","text":"<p>Public interfaces for configuration parsing operations:</p>"},{"location":"configparse/#init_configparse","title":"init_configparse","text":"<pre><code>bool init_configparse(struct configparse * this, const char * filename);\n</code></pre> <p>Initializes a configparse instance with a configuration file.</p> <p>Parameters:</p> <ul> <li><code>this</code> - Pointer to the configparse object to initialize</li> <li><code>filename</code> - The filename of the INI file to parse</li> </ul> <p>Return Value:</p> <p>Returns <code>true</code> if successful, <code>false</code> otherwise (e.g., file not found or cannot be opened).</p> <p>Example:</p> <pre><code>struct configparse parser;\nif (!init_configparse(&amp;parser, \"config.ini\")) {\n    fprintf(stderr, \"Failed to initialize parser\\n\");\n    return 1;\n}\n</code></pre>"},{"location":"configparse/#configparse_get_value","title":"configparse_get_value","text":"<pre><code>char * configparse_get_value(struct configparse * this, const char * section, const char * key);\n</code></pre> <p>Gets the value of a specific key in a section.</p> <p>Parameters:</p> <ul> <li><code>this</code> - Pointer to the configparse object</li> <li><code>section</code> - The section name where the key is located</li> <li><code>key</code> - The key name</li> </ul> <p>Return Value:</p> <p>Returns a pointer to the value string, or <code>NULL</code> if the key is not found.</p> <p>Note: Low performance, only recommended for reading specific keys in small files. When reading multiple keys, use <code>configparse_parse_all()</code> function instead.</p> <p>Example:</p> <pre><code>struct configparse parser;\ninit_configparse(&amp;parser, \"config.ini\");\n\nchar *value = configparse_get_value(&amp;parser, \"core\", \"editor\");\nif (value != NULL) {\n    printf(\"Editor: %s\\n\", value);\n}\n</code></pre>"},{"location":"configparse/#configparse_parse_all","title":"configparse_parse_all","text":"<pre><code>void configparse_parse_all(struct configparse * this, configparse_callback_t callback, void * data);\n</code></pre> <p>Parses the entire configuration file, calling the callback function for each key-value pair.</p> <p>Parameters:</p> <ul> <li><code>this</code> - Pointer to the configparse object</li> <li><code>callback</code> - Callback function to call for each key-value pair</li> <li><code>data</code> - User-provided data pointer passed to the callback function</li> </ul> <p>Note: The <code>value</code> parameter in the callback is a temporary pointer. If you need to store the value, copy it to a new string using <code>strdup()</code> or similar.</p> <p>Example:</p> <pre><code>void config_callback(void* data, const char* section, const char* key, const char* value) {\n    printf(\"Section: %s, Key: %s, Value: %s\\n\", section, key, value);\n}\n\nstruct configparse parser;\ninit_configparse(&amp;parser, \"config.ini\");\nconfigparse_parse_all(&amp;parser, config_callback, NULL);\n</code></pre>"},{"location":"configparse/#usage-examples","title":"Usage Examples","text":""},{"location":"configparse/#basic-usage","title":"Basic Usage","text":"<pre><code>#include &lt;configparse.h&gt;\n#include &lt;stdio.h&gt;\n\nvoid config_callback(void* data, const char* section, const char* key, const char* value) {\n    printf(\"Section: %s, Key: %s, Value: %s\\n\", section, key, value);\n}\n\nint main(void) {\n    struct configparse parser;\n    if (!init_configparse(&amp;parser, \"config.ini\")) {\n        fprintf(stderr, \"Failed to initialize parser\\n\");\n        return 1;\n    }\n\n    configparse_parse_all(&amp;parser, config_callback, NULL);\n\n    return 0;\n}\n</code></pre>"},{"location":"configparse/#with-custom-data-structure","title":"With Custom Data Structure","text":"<pre><code>#include &lt;configparse.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdlib.h&gt;\n\ntypedef struct {\n    const char* key;\n    const char* value;\n} callback_data_t;\n\nvoid config_callback(void* data, const char* section, const char* key, const char* value) {\n    callback_data_t* callback_data = (callback_data_t*)data;\n    printf(\"Section: %s, Key: %s, Value: %s\\n\", section, key, value);\n\n    // Store values if needed (copy the string)\n    if (strcmp(key, callback_data-&gt;key) == 0) {\n        callback_data-&gt;value = strdup(value);\n    }\n}\n\nint main(void) {\n    struct configparse parser;\n    if (!init_configparse(&amp;parser, \"config.ini\")) {\n        fprintf(stderr, \"Failed to initialize parser\\n\");\n        return 1;\n    }\n\n    callback_data_t data = { \"editor\", NULL };\n    configparse_parse_all(&amp;parser, config_callback, &amp;data);\n\n    if (data.value != NULL) {\n        printf(\"Found editor: %s\\n\", data.value);\n        free((void*)data.value);\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"configparse/#reading-specific-values","title":"Reading Specific Values","text":"<pre><code>#include &lt;configparse.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    struct configparse parser;\n    if (!init_configparse(&amp;parser, \"config.ini\")) {\n        fprintf(stderr, \"Failed to initialize parser\\n\");\n        return 1;\n    }\n\n    char *editor = configparse_get_value(&amp;parser, \"core\", \"editor\");\n    char *excludesfile = configparse_get_value(&amp;parser, \"core\", \"excludesfile\");\n\n    if (editor != NULL) {\n        printf(\"Editor: %s\\n\", editor);\n    }\n    if (excludesfile != NULL) {\n        printf(\"Excludes file: %s\\n\", excludesfile);\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"configparse/#example-ini-file-format","title":"Example INI File Format","text":"<p>The parser supports standard INI file format with sections, subsections, and key-value pairs:</p> <pre><code>[core]\n    editor = vim\n    excludesfile = ~/.gitignore\n\n[remote \"origin\"]\n    url = git@github.com:username/repo.git\n    fetch = +refs/heads/*:refs/remotes/origin/*\n</code></pre>"},{"location":"configparse/#important-notes","title":"Important Notes","text":""},{"location":"configparse/#file-format-support","title":"File Format Support","text":"<ul> <li>The parser supports standard INI file format with sections, subsections, and key-value pairs</li> <li>Section names can be quoted to include spaces or special characters</li> <li>Comments start with <code>#</code> or <code>;</code> and continue to the end of the line</li> <li>Empty lines are ignored</li> <li>Key-value pairs can be indented</li> </ul>"},{"location":"configparse/#memory-management","title":"Memory Management","text":"<ul> <li>The parser manages file operations internally</li> <li>String values returned by <code>configparse_get_value()</code> are temporary pointers</li> <li>If you need to store values, copy them using <code>strdup()</code> or similar functions</li> </ul>"},{"location":"configparse/#performance-considerations","title":"Performance Considerations","text":"<ul> <li><code>configparse_get_value()</code> has low performance and should only be used for reading specific keys in small files</li> <li>For reading multiple keys or larger files, use <code>configparse_parse_all()</code> with a callback function</li> <li>The parser reads the file sequentially</li> </ul>"},{"location":"configparse/#thread-safety","title":"Thread Safety","text":"<p>Configparse operations are not thread-safe. External synchronization is required for concurrent access.</p>"},{"location":"configparse/#important-usage-notes","title":"Important Usage Notes","text":"<ul> <li>Always check the return value of <code>init_configparse()</code> before using the parser</li> <li>Don't modify the configuration file while parsing</li> <li>String pointers returned by <code>configparse_get_value()</code> are temporary - copy them if you need to store values</li> <li>For better performance with multiple keys, use <code>configparse_parse_all()</code> instead of multiple <code>configparse_get_value()</code> calls</li> </ul>"},{"location":"utest/","title":"Utest","text":"<p>The <code>Utest</code> module provides a lightweight, modular unit testing framework for C, designed to make writing and running tests simple and expressive. It provides a rich set of macros for defining test cases, test suites, and a variety of assertions for different data types.</p>"},{"location":"utest/#header-files","title":"Header Files","text":"<p>To use the utest module in your code, include the header file:</p> <pre><code>#include &lt;utest.h&gt;\n</code></pre> <p>This provides access to all test declaration macros, assertion macros, and framework control macros.</p>"},{"location":"utest/#macros","title":"Macros","text":""},{"location":"utest/#test-declaration-and-execution","title":"Test Declaration and Execution","text":""},{"location":"utest/#utest_test_case","title":"UTEST_TEST_CASE","text":"<pre><code>UTEST_TEST_CASE(TEST_CASE_NAME)\n</code></pre> <p>Declares a test case with the given name.</p> <p>Parameters:</p> <ul> <li><code>TEST_CASE_NAME</code> - The name of the test case</li> </ul> <p>Example:</p> <pre><code>UTEST_TEST_CASE(MyFirstTest) {\n    EXPECT_EQUAL_INT(1 + 1, 2);\n    EXPECT_TRUE(5 &gt; 3);\n}\n</code></pre>"},{"location":"utest/#utest_run_test_case","title":"UTEST_RUN_TEST_CASE","text":"<pre><code>UTEST_RUN_TEST_CASE(TEST_CASE_NAME)\n</code></pre> <p>Runs a test case. This macro should be called inside a test suite.</p> <p>Parameters:</p> <ul> <li><code>TEST_CASE_NAME</code> - The name of the test case to run</li> </ul> <p>Example:</p> <pre><code>UTEST_TEST_SUITE(MySuite) {\n    UTEST_RUN_TEST_CASE(MyFirstTest);\n    UTEST_RUN_TEST_CASE(MySecondTest);\n}\n</code></pre>"},{"location":"utest/#utest_test_suite","title":"UTEST_TEST_SUITE","text":"<pre><code>UTEST_TEST_SUITE(TEST_SUITE_NAME)\n</code></pre> <p>Declares a test suite with the given name.</p> <p>Parameters:</p> <ul> <li><code>TEST_SUITE_NAME</code> - The name of the test suite</li> </ul> <p>Example:</p> <pre><code>UTEST_TEST_SUITE(MySuite) {\n    UTEST_RUN_TEST_CASE(MyFirstTest);\n    UTEST_RUN_TEST_CASE(MySecondTest);\n}\n</code></pre>"},{"location":"utest/#utest_run_test_suite","title":"UTEST_RUN_TEST_SUITE","text":"<pre><code>UTEST_RUN_TEST_SUITE(TEST_SUITE_NAME)\n</code></pre> <p>Runs a test suite. This macro should be called in the main function.</p> <p>Parameters:</p> <ul> <li><code>TEST_SUITE_NAME</code> - The name of the test suite to run</li> </ul> <p>Example:</p> <pre><code>int main(void) {\n    UTEST_BEGIN();\n    UTEST_RUN_TEST_SUITE(MySuite);\n    UTEST_END();\n    return 0;\n}\n</code></pre>"},{"location":"utest/#utest_begin","title":"UTEST_BEGIN","text":"<pre><code>UTEST_BEGIN()\n</code></pre> <p>Initializes the Utest framework. Must be called before running any test suites.</p> <p>Example:</p> <pre><code>int main(void) {\n    UTEST_BEGIN();\n    UTEST_RUN_TEST_SUITE(MySuite);\n    UTEST_END();\n    return 0;\n}\n</code></pre>"},{"location":"utest/#utest_end","title":"UTEST_END","text":"<pre><code>UTEST_END()\n</code></pre> <p>Finalizes the Utest framework. Must be called after running all test suites.</p> <p>Example:</p> <pre><code>int main(void) {\n    UTEST_BEGIN();\n    UTEST_RUN_TEST_SUITE(MySuite);\n    UTEST_END();\n    return 0;\n}\n</code></pre>"},{"location":"utest/#flag-management","title":"Flag Management","text":""},{"location":"utest/#utest_set_flag","title":"UTEST_SET_FLAG","text":"<pre><code>UTEST_SET_FLAG(UTEST_FLAG)\n</code></pre> <p>Sets a flag (bitwise) for the utest library.</p> <p>Parameters:</p> <ul> <li><code>UTEST_FLAG</code> - The flag to set</li> </ul> <p>Example:</p> <pre><code>UTEST_SET_FLAG(UTEST_FLAG_SHOW_CASE);\n</code></pre>"},{"location":"utest/#utest_clear_flag","title":"UTEST_CLEAR_FLAG","text":"<pre><code>UTEST_CLEAR_FLAG(UTEST_FLAG)\n</code></pre> <p>Clears a flag (bitwise) for the utest library.</p> <p>Parameters:</p> <ul> <li><code>UTEST_FLAG</code> - The flag to clear</li> </ul> <p>Example:</p> <pre><code>UTEST_CLEAR_FLAG(UTEST_FLAG_STYLE_FULL);\n</code></pre>"},{"location":"utest/#utest_flag_reset","title":"UTEST_FLAG_RESET","text":"<pre><code>UTEST_FLAG_RESET()\n</code></pre> <p>Resets all flags to the default value.</p> <p>Example:</p> <pre><code>UTEST_FLAG_RESET();\n</code></pre>"},{"location":"utest/#flags","title":"Flags","text":"<p>Utest supports runtime flags to control output and behavior:</p> Flag Description <code>UTEST_FLAG_NONE</code> No special behavior <code>UTEST_FLAG_SHOW_CASE</code> Show each test case result <code>UTEST_FLAG_SHOW_SUITE</code> Show each test suite result <code>UTEST_FLAG_STYLE_FULL</code> Use full output style <code>UTEST_FLAG_STOP_ON_FAILURE</code> Stop on first failure <code>UTEST_FLAG_DEFAULT</code> Default flag set"},{"location":"utest/#integer-assertions","title":"Integer Assertions","text":""},{"location":"utest/#equality-assertions","title":"Equality Assertions","text":"<ul> <li><code>EXPECT_EQUAL_INT(ACTUAL, EXPECTED)</code> - Expects two integers to be equal</li> <li><code>EXPECT_EQUAL_INT8(ACTUAL, EXPECTED)</code> - Expects two 8-bit integers to be equal</li> <li><code>EXPECT_EQUAL_INT16(ACTUAL, EXPECTED)</code> - Expects two 16-bit integers to be equal</li> <li><code>EXPECT_EQUAL_INT32(ACTUAL, EXPECTED)</code> - Expects two 32-bit integers to be equal</li> <li><code>EXPECT_EQUAL_INT64(ACTUAL, EXPECTED)</code> - Expects two 64-bit integers to be equal</li> </ul> <p>Example:</p> <pre><code>UTEST_TEST_CASE(TestAddition) {\n    EXPECT_EQUAL_INT(2 + 2, 4);\n    EXPECT_EQUAL_INT32(100, 100);\n}\n</code></pre>"},{"location":"utest/#inequality-assertions","title":"Inequality Assertions","text":"<ul> <li><code>EXPECT_NOT_EQUAL_INT(ACTUAL, EXPECTED)</code> - Expects two integers to be not equal</li> <li><code>EXPECT_NOT_EQUAL_INT8(ACTUAL, EXPECTED)</code> - Expects two 8-bit integers to be not equal</li> <li><code>EXPECT_NOT_EQUAL_INT16(ACTUAL, EXPECTED)</code> - Expects two 16-bit integers to be not equal</li> <li><code>EXPECT_NOT_EQUAL_INT32(ACTUAL, EXPECTED)</code> - Expects two 32-bit integers to be not equal</li> <li><code>EXPECT_NOT_EQUAL_INT64(ACTUAL, EXPECTED)</code> - Expects two 64-bit integers to be not equal</li> </ul> <p>Example:</p> <pre><code>UTEST_TEST_CASE(TestInequality) {\n    EXPECT_NOT_EQUAL_INT(1, 2);\n}\n</code></pre>"},{"location":"utest/#greater-than-assertions","title":"Greater Than Assertions","text":"<ul> <li><code>EXPECT_GREATER_INT(ACTUAL, EXPECTED)</code> - Expects actual to be greater than expected</li> <li><code>EXPECT_GREATER_INT8(ACTUAL, EXPECTED)</code> - Expects actual to be greater than expected (8-bit)</li> <li><code>EXPECT_GREATER_INT16(ACTUAL, EXPECTED)</code> - Expects actual to be greater than expected (16-bit)</li> <li><code>EXPECT_GREATER_INT32(ACTUAL, EXPECTED)</code> - Expects actual to be greater than expected (32-bit)</li> <li><code>EXPECT_GREATER_INT64(ACTUAL, EXPECTED)</code> - Expects actual to be greater than expected (64-bit)</li> </ul> <p>Example:</p> <pre><code>UTEST_TEST_CASE(TestGreater) {\n    EXPECT_GREATER_INT(5, 3);\n}\n</code></pre>"},{"location":"utest/#greater-than-or-equal-assertions","title":"Greater Than or Equal Assertions","text":"<ul> <li><code>EXPECT_GREATER_EQUAL_INT(ACTUAL, EXPECTED)</code> - Expects actual to be greater than or equal to expected</li> <li><code>EXPECT_GREATER_EQUAL_INT8(ACTUAL, EXPECTED)</code> - Expects actual to be greater than or equal to expected (8-bit)</li> <li><code>EXPECT_GREATER_EQUAL_INT16(ACTUAL, EXPECTED)</code> - Expects actual to be greater than or equal to expected (16-bit)</li> <li><code>EXPECT_GREATER_EQUAL_INT32(ACTUAL, EXPECTED)</code> - Expects actual to be greater than or equal to expected (32-bit)</li> <li><code>EXPECT_GREATER_EQUAL_INT64(ACTUAL, EXPECTED)</code> - Expects actual to be greater than or equal to expected (64-bit)</li> </ul> <p>Example:</p> <pre><code>UTEST_TEST_CASE(TestGreaterEqual) {\n    EXPECT_GREATER_EQUAL_INT(5, 5);\n    EXPECT_GREATER_EQUAL_INT(6, 5);\n}\n</code></pre>"},{"location":"utest/#less-than-assertions","title":"Less Than Assertions","text":"<ul> <li><code>EXPECT_LESS_INT(ACTUAL, EXPECTED)</code> - Expects actual to be less than expected</li> <li><code>EXPECT_LESS_INT8(ACTUAL, EXPECTED)</code> - Expects actual to be less than expected (8-bit)</li> <li><code>EXPECT_LESS_INT16(ACTUAL, EXPECTED)</code> - Expects actual to be less than expected (16-bit)</li> <li><code>EXPECT_LESS_INT32(ACTUAL, EXPECTED)</code> - Expects actual to be less than expected (32-bit)</li> <li><code>EXPECT_LESS_INT64(ACTUAL, EXPECTED)</code> - Expects actual to be less than expected (64-bit)</li> </ul> <p>Example:</p> <pre><code>UTEST_TEST_CASE(TestLess) {\n    EXPECT_LESS_INT(3, 5);\n}\n</code></pre>"},{"location":"utest/#less-than-or-equal-assertions","title":"Less Than or Equal Assertions","text":"<ul> <li><code>EXPECT_LESS_EQUAL_INT(ACTUAL, EXPECTED)</code> - Expects actual to be less than or equal to expected</li> <li><code>EXPECT_LESS_EQUAL_INT8(ACTUAL, EXPECTED)</code> - Expects actual to be less than or equal to expected (8-bit)</li> <li><code>EXPECT_LESS_EQUAL_INT16(ACTUAL, EXPECTED)</code> - Expects actual to be less than or equal to expected (16-bit)</li> <li><code>EXPECT_LESS_EQUAL_INT32(ACTUAL, EXPECTED)</code> - Expects actual to be less than or equal to expected (32-bit)</li> <li><code>EXPECT_LESS_EQUAL_INT64(ACTUAL, EXPECTED)</code> - Expects actual to be less than or equal to expected (64-bit)</li> </ul> <p>Example:</p> <pre><code>UTEST_TEST_CASE(TestLessEqual) {\n    EXPECT_LESS_EQUAL_INT(5, 5);\n    EXPECT_LESS_EQUAL_INT(3, 5);\n}\n</code></pre>"},{"location":"utest/#unsigned-integer-assertions","title":"Unsigned Integer Assertions","text":"<p>All integer assertion macros have unsigned variants with <code>UINT</code> in the macro name:</p>"},{"location":"utest/#equality-assertions_1","title":"Equality Assertions","text":"<ul> <li><code>EXPECT_EQUAL_UINT(ACTUAL, EXPECTED)</code> - Expects two unsigned integers to be equal</li> <li><code>EXPECT_EQUAL_UINT8(ACTUAL, EXPECTED)</code> - Expects two 8-bit unsigned integers to be equal</li> <li><code>EXPECT_EQUAL_UINT16(ACTUAL, EXPECTED)</code> - Expects two 16-bit unsigned integers to be equal</li> <li><code>EXPECT_EQUAL_UINT32(ACTUAL, EXPECTED)</code> - Expects two 32-bit unsigned integers to be equal</li> <li><code>EXPECT_EQUAL_UINT64(ACTUAL, EXPECTED)</code> - Expects two 64-bit unsigned integers to be equal</li> </ul>"},{"location":"utest/#other-unsigned-integer-assertions","title":"Other Unsigned Integer Assertions","text":"<ul> <li><code>EXPECT_NOT_EQUAL_UINT(ACTUAL, EXPECTED)</code> and variants</li> <li><code>EXPECT_GREATER_UINT(ACTUAL, EXPECTED)</code> and variants</li> <li><code>EXPECT_GREATER_EQUAL_UINT(ACTUAL, EXPECTED)</code> and variants</li> <li><code>EXPECT_LESS_UINT(ACTUAL, EXPECTED)</code> and variants</li> <li><code>EXPECT_LESS_EQUAL_UINT(ACTUAL, EXPECTED)</code> and variants</li> </ul> <p>Example:</p> <pre><code>UTEST_TEST_CASE(TestUnsigned) {\n    EXPECT_EQUAL_UINT(10u, 10u);\n    EXPECT_GREATER_UINT(20u, 10u);\n}\n</code></pre>"},{"location":"utest/#floating-point-assertions","title":"Floating Point Assertions","text":""},{"location":"utest/#float-assertions","title":"Float Assertions","text":"<ul> <li><code>EXPECT_EQUAL_FLOAT(ACTUAL, EXPECTED)</code> - Expects two floats to be equal</li> <li><code>EXPECT_NOT_EQUAL_FLOAT(ACTUAL, EXPECTED)</code> - Expects two floats to be not equal</li> <li><code>EXPECT_GREATER_FLOAT(ACTUAL, EXPECTED)</code> - Expects actual float to be greater than expected</li> <li><code>EXPECT_GREATER_EQUAL_FLOAT(ACTUAL, EXPECTED)</code> - Expects actual float to be greater than or equal to expected</li> <li><code>EXPECT_LESS_FLOAT(ACTUAL, EXPECTED)</code> - Expects actual float to be less than expected</li> <li><code>EXPECT_LESS_EQUAL_FLOAT(ACTUAL, EXPECTED)</code> - Expects actual float to be less than or equal to expected</li> </ul> <p>Example:</p> <pre><code>UTEST_TEST_CASE(TestFloat) {\n    EXPECT_EQUAL_FLOAT(3.14f, 3.14f);\n    EXPECT_GREATER_FLOAT(5.0f, 3.0f);\n}\n</code></pre>"},{"location":"utest/#double-assertions","title":"Double Assertions","text":"<ul> <li><code>EXPECT_EQUAL_DOUBLE(ACTUAL, EXPECTED)</code> - Expects two doubles to be equal</li> <li><code>EXPECT_NOT_EQUAL_DOUBLE(ACTUAL, EXPECTED)</code> - Expects two doubles to be not equal</li> <li><code>EXPECT_GREATER_DOUBLE(ACTUAL, EXPECTED)</code> - Expects actual double to be greater than expected</li> <li><code>EXPECT_GREATER_EQUAL_DOUBLE(ACTUAL, EXPECTED)</code> - Expects actual double to be greater than or equal to expected</li> <li><code>EXPECT_LESS_DOUBLE(ACTUAL, EXPECTED)</code> - Expects actual double to be less than expected</li> <li><code>EXPECT_LESS_EQUAL_DOUBLE(ACTUAL, EXPECTED)</code> - Expects actual double to be less than or equal to expected</li> </ul> <p>Example:</p> <pre><code>UTEST_TEST_CASE(TestDouble) {\n    EXPECT_EQUAL_DOUBLE(3.14159, 3.14159);\n    EXPECT_LESS_DOUBLE(2.5, 3.0);\n}\n</code></pre>"},{"location":"utest/#string-assertions","title":"String Assertions","text":"<ul> <li><code>EXPECT_EQUAL_STRING(ACTUAL, EXPECTED)</code> - Expects two strings to be equal</li> <li><code>EXPECT_NOT_EQUAL_STRING(ACTUAL, EXPECTED)</code> - Expects two strings to be not equal</li> <li><code>EXPECT_GREATER_STRING(ACTUAL, EXPECTED)</code> - Expects actual string to be greater than expected (lexicographically)</li> <li><code>EXPECT_GREATER_EQUAL_STRING(ACTUAL, EXPECTED)</code> - Expects actual string to be greater than or equal to expected</li> <li><code>EXPECT_LESS_STRING(ACTUAL, EXPECTED)</code> - Expects actual string to be less than expected (lexicographically)</li> <li><code>EXPECT_LESS_EQUAL_STRING(ACTUAL, EXPECTED)</code> - Expects actual string to be less than or equal to expected</li> </ul> <p>Example:</p> <pre><code>UTEST_TEST_CASE(TestString) {\n    EXPECT_EQUAL_STRING(\"hello\", \"hello\");\n    EXPECT_NOT_EQUAL_STRING(\"hello\", \"world\");\n    EXPECT_LESS_STRING(\"apple\", \"banana\");\n}\n</code></pre>"},{"location":"utest/#pointer-assertions","title":"Pointer Assertions","text":"<ul> <li><code>EXPECT_NULL(POINTER)</code> - Expects pointer to be NULL</li> <li><code>EXPECT_NOT_NULL(POINTER)</code> - Expects pointer to be not NULL</li> </ul> <p>Example:</p> <pre><code>UTEST_TEST_CASE(TestPointer) {\n    void *ptr = NULL;\n    EXPECT_NULL(ptr);\n\n    int value = 42;\n    void *ptr2 = &amp;value;\n    EXPECT_NOT_NULL(ptr2);\n}\n</code></pre>"},{"location":"utest/#boolean-assertions","title":"Boolean Assertions","text":"<ul> <li><code>EXPECT_TRUE(EXPRESSION)</code> - Expects expression to be true (non-zero)</li> <li><code>EXPECT_FALSE(EXPRESSION)</code> - Expects expression to be false (zero)</li> </ul> <p>Example:</p> <pre><code>UTEST_TEST_CASE(TestBoolean) {\n    EXPECT_TRUE(5 &gt; 3);\n    EXPECT_FALSE(3 &gt; 5);\n    EXPECT_TRUE(1);\n    EXPECT_FALSE(0);\n}\n</code></pre>"},{"location":"utest/#usage-examples","title":"Usage Examples","text":""},{"location":"utest/#basic-usage","title":"Basic Usage","text":"<pre><code>#include &lt;utest.h&gt;\n\nUTEST_TEST_CASE(Addition) {\n    EXPECT_EQUAL_INT(2 + 2, 4);\n}\n\nUTEST_TEST_CASE(Subtraction) {\n    EXPECT_EQUAL_INT(5 - 3, 2);\n}\n\nUTEST_TEST_SUITE(MathTests) {\n    UTEST_RUN_TEST_CASE(Addition);\n    UTEST_RUN_TEST_CASE(Subtraction);\n}\n\nint main(void) {\n    UTEST_BEGIN();\n    UTEST_RUN_TEST_SUITE(MathTests);\n    UTEST_END();\n    return 0;\n}\n</code></pre>"},{"location":"utest/#with-flags","title":"With Flags","text":"<pre><code>#include &lt;utest.h&gt;\n\nUTEST_TEST_CASE(Addition) {\n    EXPECT_EQUAL_INT(2 + 2, 4);\n}\n\nUTEST_TEST_SUITE(MathTests) {\n    UTEST_RUN_TEST_CASE(Addition);\n}\n\nint main(void) {\n    UTEST_BEGIN();\n    UTEST_CLEAR_FLAG(UTEST_FLAG_STYLE_FULL);\n    UTEST_SET_FLAG(UTEST_FLAG_SHOW_CASE);\n    UTEST_RUN_TEST_SUITE(MathTests);\n    UTEST_END();\n    return 0;\n}\n</code></pre>"},{"location":"utest/#multiple-test-suites","title":"Multiple Test Suites","text":"<pre><code>#include &lt;utest.h&gt;\n\nUTEST_TEST_CASE(Test1) {\n    EXPECT_EQUAL_INT(1, 1);\n}\n\nUTEST_TEST_CASE(Test2) {\n    EXPECT_EQUAL_STRING(\"hello\", \"hello\");\n}\n\nUTEST_TEST_SUITE(Suite1) {\n    UTEST_RUN_TEST_CASE(Test1);\n}\n\nUTEST_TEST_SUITE(Suite2) {\n    UTEST_RUN_TEST_CASE(Test2);\n}\n\nint main(void) {\n    UTEST_BEGIN();\n    UTEST_RUN_TEST_SUITE(Suite1);\n    UTEST_RUN_TEST_SUITE(Suite2);\n    UTEST_END();\n    return 0;\n}\n</code></pre>"},{"location":"utest/#comprehensive-example","title":"Comprehensive Example","text":"<pre><code>#include &lt;utest.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdlib.h&gt;\n\nUTEST_TEST_CASE(TestIntegers) {\n    EXPECT_EQUAL_INT(10, 10);\n    EXPECT_NOT_EQUAL_INT(10, 20);\n    EXPECT_GREATER_INT(20, 10);\n    EXPECT_LESS_INT(10, 20);\n}\n\nUTEST_TEST_CASE(TestStrings) {\n    EXPECT_EQUAL_STRING(\"test\", \"test\");\n    EXPECT_NOT_EQUAL_STRING(\"test\", \"fail\");\n}\n\nUTEST_TEST_CASE(TestPointers) {\n    int value = 42;\n    int *ptr = &amp;value;\n    EXPECT_NOT_NULL(ptr);\n    EXPECT_NULL(NULL);\n}\n\nUTEST_TEST_CASE(TestBooleans) {\n    EXPECT_TRUE(1);\n    EXPECT_FALSE(0);\n    EXPECT_TRUE(5 &gt; 3);\n}\n\nUTEST_TEST_SUITE(AllTests) {\n    UTEST_RUN_TEST_CASE(TestIntegers);\n    UTEST_RUN_TEST_CASE(TestStrings);\n    UTEST_RUN_TEST_CASE(TestPointers);\n    UTEST_RUN_TEST_CASE(TestBooleans);\n}\n\nint main(void) {\n    UTEST_BEGIN();\n    UTEST_RUN_TEST_SUITE(AllTests);\n    UTEST_END();\n    return 0;\n}\n</code></pre>"},{"location":"utest/#important-notes","title":"Important Notes","text":""},{"location":"utest/#test-organization","title":"Test Organization","text":"<ul> <li>Test cases must be declared before they are used in test suites</li> <li>Test suites can contain multiple test cases</li> <li>Multiple test suites can be run in a single program</li> <li>Always call <code>UTEST_BEGIN()</code> before running tests and <code>UTEST_END()</code> after</li> </ul>"},{"location":"utest/#assertion-behavior","title":"Assertion Behavior","text":"<ul> <li>Assertions do not stop execution on failure by default</li> <li>Use <code>UTEST_FLAG_STOP_ON_FAILURE</code> flag to stop on first failure</li> <li>Failed assertions are reported in the test output</li> <li>All assertions in a test case are evaluated unless stopped by flags</li> </ul>"},{"location":"utest/#thread-safety","title":"Thread Safety","text":"<p>Utest operations are not thread-safe. External synchronization is required for concurrent test execution.</p>"},{"location":"utest/#undefined-behavior","title":"Undefined Behavior","text":"<p>Avoid the following:</p> <ul> <li>Calling test macros outside of proper test case/suite contexts</li> <li>Not calling <code>UTEST_BEGIN()</code> before running tests</li> <li>Not calling <code>UTEST_END()</code> after running tests</li> <li>Using test case names that conflict with C keywords or other identifiers</li> </ul>"}]}